#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Dec 20 23:25:41 2018
General PIV analysis for image pairs
@author: deepak
"""
import openpiv.tools
import openpiv.scaling
import openpiv.process
import numpy as np
import openpiv.validation
import openpiv.filters
import csv as csv
import openpiv.tools
import openpiv.process
import openpiv.scaling
import openpiv.validation
import openpiv.filters
import cv2
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import cmocean
import os
import time
import scipy
import scipy.ndimage as ndimage
from roipoly import roipoly
from mpl_toolkits.axes_grid1.anchored_artists import AnchoredSizeBar
import pickle
plt.close("all")
from PIL import Image
import imp
import Track
imp.reload(Track)
import FigureParameters
from mpl_toolkits.axes_grid1 import make_axes_locatable
#==============================================================================
# PIV Analysis
#==============================================================================
def doPIV(frame_a_color,frame_b_color, dT = 1.0, sign2noise_min=1.5, pixel2mm = 1.0, smoothing_param = 2.0):
       
    frame_a = cv2.cvtColor(frame_a_color , cv2.COLOR_BGR2GRAY)
    frame_b = cv2.cvtColor(frame_b_color , cv2.COLOR_BGR2GRAY)
    win_size = 48
    overlap = 24
    searchArea = 48
    u, v, sig2noise = openpiv.process.extended_search_area_piv( frame_a.astype(np.int32), frame_b.astype(np.int32), window_size = win_size, overlap = overlap, dt = dT, search_area_size = searchArea, sig2noise_method='peak2peak' )
    
    x, y = openpiv.process.get_coordinates( image_size=frame_a.shape, window_size = win_size, overlap = overlap )

    u,v = pivPostProcess(u,v,sig2noise,sig2noise_min = 1.5 ,smoothing_param = 2.0)
    #x, y, u, v = openpiv.scaling.uniform(x, y, u, v, scaling_factor = 100 )
    
   # openpiv.tools.save(x, y, u, v, mask, 'exp1_001.txt' )
   
    #openpiv.tools.display_vector_field('exp1_001.txt', scale=0.01, width=0.0025)
    return x,y,u,v

def pivPostProcess(u,v,sig2noise,sig2noise_min=1.5,smoothing_param=2.0):
    
    u, v, mask = openpiv.validation.sig2noise_val( u, v, sig2noise, threshold = sig2noise_min )

    print('-'*50)
    print('Percentage of bad vectors: {} %'.format(100*np.count_nonzero(np.isnan(u))/np.prod(u.shape)))
    print('-'*50)    
    u, v = openpiv.filters.replace_outliers( u, v, method='localmean', max_iter=10, kernel_size=2)
    
#    (u,v) =(np.flipud(u), np.flipud(v))
    
    (u,v)=(smoothData(u,sigma_smooth=1.5), smoothData(v,sigma_smooth=1.5))
    
    return u,v

def data2RealUnits(data,scale=1.0):
    return data*scale

def smoothData(data,sigma_smooth=1.0,order_=0):
     return ndimage.gaussian_filter(data, sigma= sigma_smooth, order= order_)
 
#==============================================================================
# Find subset of points that lie inside a contour
#==============================================================================
def pointInContour(x,y,contour):
    
    H = np.shape(x)[0]
    W = np.shape(x)[1]
    mask = np.zeros_like(x,dtype='bool')
    for i in range(0,H):
        for j in range(0,W):
            x_,y_ = (x[i,j],y[i,j])
            dist= cv2.pointPolygonTest(contour,(x_,y_),False)
            # Create a mask of points which lie inside the contour
            if(dist>=0):
                mask[i,j]=1
    return mask

#==============================================================================
def velMag(u,v):
    return np.sqrt((u**2+v**2))
#==============================================================================
def plotPIVdata(image,x,y,u,v, orgContour,figname=1,show = 0,saveFileName='PIVdata.tif'):
    # Plots the PIV vector field overlaid on the raw image
    imH, imW, *rest = np.shape(image)
    
    maskInside = pointInContour(np.flipud(x),np.flipud(y),orgContour)
    x, y = (x*mmPerPixel(imW), y*mmPerPixel(imW))
    u[maskInside] = np.nan
    v[maskInside] = np.nan
    U = velMag(u,v)
       
#    U_min = 0
#    U_max = 1.2
    
#    u,v, U = (np.flipud(u), np.flipud(v), np.flipud(U))
    y = np.flipud(y)
    
    fig = plt.figure(figname,figsize=(12,8))
#    plt.ioff()
    plt.clf()
    ax =plt.gca()
#    cv2.drawContours(image, [orgContour], -1,(0,255,0), 3)
    ax1 = plt.imshow(image,cmap=plt.cm.gray,alpha=1.0, extent = [0,mmPerPixel(imW)*imW,mmPerPixel(imW)*imH, 0])
    ax2 = plt.contourf(x, y, U, cmap = cmocean.cm.amp, alpha=1.0,linewidth=0,linestyle=None)
    
    #ax2 = plt.pcolor(x,y,U,cmap = cmocean.cm.amp)
    #ax1 = plt.quiver(x,y,u,v,U,cmap = cmocean.cm.solar)
    #ax3 = plt.streamplot(x,y,u,v)
    
#    ax3 = plt.quiver(x,y,u,v,U,cmap = cmocean.cm.amp)
    ax4 = plt.streamplot(x,y,u,-v,color=[1,1,1,0.75],linewidth = 1.2, density = 1.5, arrowsize=0.001)

    ax3 = plt.quiver(x[::2],y[::2],u[::2],v[::2],color=[0,0,0,1])

  

    cbar = plt.colorbar(ax2)
    
    
    

    cbar.set_label('Flow velocity magnitude (mm/s)')
    plt.axis('image')
    
#    
    plt.savefig(saveFileName,dpi=300)
#    if(show==1):
    plt.show(block=False)
    plt.pause(0.001)
#    plt.show()
    
    
    

#==============================================================================
# Extract the image region corresponding to the organism.
#============================================================================== 
def findCentroids(contours):
    
    Centroids = []
    for ii,cnts in enumerate(contours):
        
        M = cv2.moments(cnts)
                
        ((x, y), radius) = cv2.minEnclosingCircle(cnts)
        
        objCentroid = np.array((int(M["m10"] / M["m00"]), int(M["m01"] / M["m00"])))
        
        Centroids.append(objCentroid)
        
    return Centroids
        
    
def findContours(image,thresh_low,thresh_high, SelectContours = 'all'):
    # Find all object contours in an image
    thresh_low = np.array(thresh_low,dtype='uint8')
    thresh_high = np.array(thresh_high,dtype='uint8')
    
    print(thresh_low)
    print(thresh_high)
    
    im_th = cv2.inRange(image, thresh_low, thresh_high)
    
    kernel3 = np.ones((3,3),np.uint8)
    kernel5 = np.ones((5,5),np.uint8)
    kernel7 = np.ones((7,7),np.uint8)
    kernel15 = np.ones((15,15),np.uint8)
    
    
    im_th = cv2.morphologyEx(im_th, cv2.MORPH_CLOSE, kernel5)
    
    im_th = cv2.morphologyEx(im_th, cv2.MORPH_CLOSE, kernel7)
    
    im_th = cv2.morphologyEx(im_th, cv2.MORPH_OPEN, kernel7)
    
    im_th = cv2.morphologyEx(im_th, cv2.MORPH_CLOSE, kernel15)

    
#    plt.matshow(im_th , cmap=cm.Greys_r )
#    plt.title('Thresholded Image')
#    plt.show()
    
    # Select the largest contour as the final mask
    cnts = cv2.findContours(im_th,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)[-2]
    
    print('No:of contours:{}'.format(len(cnts)))
    
   
    if(SelectContours =='largest'):
        largestContour = max(cnts, key=cv2.contourArea)
        return largestContour
    elif (SelectContours == 'all'):
        return cnts
    
    
    
   
#==============================================================================
def find_nearest(array, value):
    array = np.asarray(array)
    idx = (np.abs(array - value)).argmin()
    return idx, array[idx] 
#============================================================================== 
def mmPerPixel(resolution_width):
    return 1./628/(resolution_width/1440)   #for a 1440x1080 image
def pixelPermm(resolution_width):
    return 628*resolution_width/1440
#==============================================================================
def interpolateToGrid(x,y,u,v,scaleFactor=1):
    # Takes a vector field and interpolates it onto a scaleFactor times finer grid
    x_lin = x[0,:]
    y_lin = y[:,0]
            
    f_u = scipy.interpolate.interp2d(x_lin,y_lin,u,kind = 'linear')
    f_v = scipy.interpolate.interp2d(x_lin,y_lin,v, kind = 'linear')
    
    
    dataH = np.shape(x)[0]
    dataW = np.shape(x)[1]
    #--------------------------------------------------------------------------
    # Interpolate to a finer mesh for display purposes
    #--------------------------------------------------------------------------
    x_fine_lin, y_fine_lin = (np.linspace(x.min(),x.max(),2*dataW), np.linspace(y.min(),y.max(),2*dataH))
    
    x_fine, y_fine = np.meshgrid(x_fine_lin, y_fine_lin)
    
    u_fine, v_fine = (f_u(x_fine_lin,y_fine_lin),f_v(x_fine_lin,y_fine_lin))
    
    return x_fine, y_fine, u_fine, v_fine

def main():
    
    dataFolder = '/Volumes/DEEPAK-SSD/GravityMachine/AbioticExperiments/2017_06_20_PencilLeads/HighSpeedExperiments/Ds17_Processed'
    
    FilesList = os.listdir(dataFolder)
    
    print(FilesList)
    
    print(FilesList.sort())
    
    
    
if __name__ == '__main__':
    main()
    cv2.destroyAllWindows()
    